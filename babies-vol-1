1. давайте рассмотрим такой пример
у нас есть обект swag. обект - это комплексный тип данных это значит что он может содержать в себе коллекцию каких-то данных
действительно он содержит ключ makeSwag - это функция, и ключ amISwag это boolean.
слава богу что javascript поддерживает одновременно и фенкциональный подход програмирования и обектно ореентированый подход, вель можно написать два раза больше говнокода и хаков.

ключ который содержит в себе какуюто информаци отличную от функции называется проперти
ключ который содержит в себе функцию называется метод.

2. для комплексных инстансов можно добавлять методы и свойства, вот например array зухов, можно добаить этому эррею метод makeSuperZuchami, и этот метод добавит эррею пропенти superZuchi тру.

3. а теперь другой пример, у меня есть пятерка, мне кто-то одбил. у нее тоже есть методы, методы конечно принадлежат не ей, а родителям, но вель почти каждый из вас ездил на машине папы?
можно попытаться записать в нее какие-то свойства, но они туда не влезут.

4. о привет мои дорогие null и undefined как там у вас с методами и свойствами?

5. Числа
	числа в джаваскрипте могут быть дробным числом, бесконечностью и NaN	
	числа в джаваскрипте всегда дробные
	джаваскрипт, как и другие языки не умеет точно считать
	чтобы преобразовать что-то в число лучше использовать функцию number
	практически все нужные математические фенкции доступны в фенкции Math
	для парсинга строки как числа, всегда можно попробывать использовать фенкцию parseInt, parseFloat
6. великолепный NaN
	NaN настолько крут что никто не может с ним сравниться,
	он настолько крут, что даже он сам не может сравниться с собой
	для определения яаляется ли что-то наном есть встроеная фенкция браузера isNaN, но NaN настольео крут что даже она не может определить правильно NaN это или какойто позер который хочет быть на него похожим. поэтому лучге написать свою фенкцию которая будет работать немного получге

7. Стринги
	чтобы инициалтзтровать строку достаточно испотзовать одинарные или двойные ковычки
	если мы хотим инициализировать строку и иметь возможность задать ее часть как результат выполнения скрипта - можно использовать стринг темплейт
	чтобы преобразовать что-то в строку нужно использовать фенкцию String или метод toString
8. методы строк.
все методы строк можно разбить на несколько груп. давайте поочереди их разберем.

	1 греппа это обебеденения строк.
		можно просто вдять и сложить строки - бинарный плюс отлично с этим справится.
		можно испотзовать метод concat
		или даже мтод repeat который повторит строку столько раз сколько мы указали в аргементе
	2. rozdzielać строки 
		иетод позволяет разделить строку на подстроки - разделительным символом или группой символов будет агрумент фенкции который мы подадим, результатом выполнения будет массив строк на которые 			была разьита строка
	3. substrings - у строки можно всегда взять подстроку для этого есть два метода - substring и slice
		оюа принимают значения старт - енд, но по разноме работают с отрицательными аргументами, substring нтерпритирует отрицательный аргумент как 0, да к томе же меняет аргументы местами если начало больше конца
	4. чтобы поменять регистр слов можно использовать toUpper/toLowercase
	5. для того чтобы получить значение симпола на какойто позиции можно воспользоваться фенкцикй charAt или просто указать номер этого симфола в строке
	6. для триминга строк существует аэ три метода trim, trimRight, trimLeft
	7 для проверки строк есть сразу 7 методов: 
		endsWith - проверяет заканчивается ли тестируемая строка, строкой указаной в аргументе
		startsWith - проверяет начинается ли тестируемая строка, строкой указаной в аргументе
		includes - проверяет содержит ли тестируемая строка, подстроку указаную в аргументе
		indexOf, lastIndexOf - ишет подстроку указаную в аргументе, и возвращает игдекс вхождения - либо первого либо последнего. в случае если тестируемая строка не содержит искомую подстроку то 			возвращает -1 
		search, match - методы для тестировая строки с помощтю регуоярного выражения
		search работает точно так же как и indexOf 

11 массив - массив это инстанс комплексного типа данных object
	действительно если посмотреть на него повнимательнее то это обект у которого все ключи - упорядоченные числа, а значениея этих кобчей инстанс любого типа, и ключей может быть сколь угодно много.
	для того чтобы синициализировать массив можно использовать квадратные скобки или конструктор, куда можно подать аргементами элементы массива, так же можно использовать статиеский метод коеструктора - Array.of. разниуа в том то если мы используем просто конструктор и 1 аргументом - числом то фенкция просто вернет нам массив с пкстыми елементами такой длины
	чтобы проверить является ли какойто инстанс массивом, достаточно вызвать статический метод коеструктора Array.isArray
	массив как и людой косплексеый инстанс сравнивается по ссылке а не по значению.

чтобы проитерировать массив есть три разеых способа - цикл for, for in, forEach. воперных он работает медленее чем два других способо но к тому же он переберает все свойства обекта, поэтому если мы будем имееть какие-то дрегие свойства отдельные от числовых ключей то они тоже войдут в перебор

в програмировании есть два очень известных паттерна -  stack и Queue
естественно они производятся с помошью массивов

Stack - когда мы добавляем новый элемент который мы должны обработать в конец массива, и обработку ведем с конца массива - тоесть испозуем методы - добавить элемент в конец, убрать последний элемент в массиве. 
Queue - когда мы добавляем новый элемент который мы должны обработать в конец массива, и обработку ведем с начала массива - тоесть испозуем методы - добавить элемент в конец, убрать первый элемент в массиве. 

13 копирование массива
	если нам нужно сделать копию массива для этого можно воспользоваться либо спред оператором - но он создаст нам полную копию массива, либо воспользоваться методом slice

14. преобразование чего-то похожего на массив к массиву
доакстим мы решили взять все дивы которые у нас есть на странице - их оказалось не много - 2 - но сколько есть. выглядит точно как массив, только вот меотодов массива нету
а хочется поитерировать для этого к счастью есть статический метод который называется Array.from, который преобразовывает все что выглядит похоже на arrayв настоящий массив

15 а что если мы хотим объеденитьь два массива вместе. можно кончно проитерировать один массив, и сдеалать unshift все его значения в другой массив. но лучшее использовать методы массива который для этого и создан - метод называется concat. также можно использовать для этого спред оператор

16.
 а вот другой случай, у нас есть массив каких-то значений, и мы хотим ухнать удовлетворяют все значения какиму-то условию, например у насть есть массив строк и мы хотим узнать все ли строки являются ip, или еще более жизненый пример, у насть есть список фильмов, и мы хотим унать достаточны ли все эти фильмы хороши чтобы их посмотреть. причем этот метод работает в режиме short circut evaluation если для одного елемента чеккер вернет фолс то чеккер не будет выполняться для все последующих элементов массива
очень поъожий метод который проверяет удовлетворяет хотя бы один элемент массива указаному условию - например если юзер ввел много значений и хотя бы одно из них является ip то форма не показывает ошибку, или такой пример у нас есть список актеров, и если хотя бы один из них играет в фильме, то фильм хороший

17. чтобы а что если мне нужно проитерировать массив, но только в обратном порядке. сначала взять последний элемент массива, и пройтись к первогму.
можно конечно проитерировать циклом for в обратном порядке, а можно баде проитерировать 1 раз в прямом порядке и использовать метод unshift, чтобы добавлять элементы в обратном порялке в темпорари массив
а можно просто воспользоваться методом reverse, который для этого и был создан.

18 другая задача - у нас есть массив и мы хотим из него взять только те элементы которые удовлетворяют кауомето условию, конечно же можно сделать это с помошьб итерации массива матодом forEach и дополнительной переменной, 

19 тлично а что делать если мне нужно посортировать массив в зависимости от какого-то условия? для этого есть метод sort

20 массивточно так же как и строка имеет очень иного методов ддля тестирования своего содержания
	1. метод find - > принимает аргументом фенкцию checker и возвращает первый элемент массива, для которого фенкци чеккер вернет тру. либо вернет undefined
	2. метод findIndex - тоже самое что и find разница в том что возвращает не элемент массва, а индект этого элемента в массиве либо вернет -1
	3. метод indexOf - принимает аргументом - какой-то инстанс, и возвращает ено индекс первого совпадения, причем проверка идет с помощью ===, либо вернет -1
	4. lastIndexOf - работает точно так же как и indexOf только возвращает интекс последнего вхождения
	5. includes - метод проверяет содержиться ли переданый аргемент в массиве или нет

21 метод map - допустим ситуацию, у нас есть массив, и нам нужно для каждого елементи массива выполнить какуюто функцию - как-то преобазовать этот елемент масива и иметь новый массив с новыми значениями - самый простой пример, у нас есть массив скрок - например имен - и мы хотим сощдать на сервере с помощтю этих имен какие-то енции - но имена у нас могут повторяться а сервер не может создать что-то с таким же именем как уже было - самый простой способ на основе массива имен создать новый массив уникальных имен

и теперь король методов еррея, если бы все методы ерея были мстителями то это был бы стивен роджерс - редьюс настолько крут что с его помощью можно воспроизвести любой другой итерирующий метод ерея.
вы млжете сказать да он крут но как же метод forEach c его помощью можно все сделать, но сравнивать forEachб это как сравнивать тони старка с стивеном роджерсом. без костюма он всего лиш гений и миллиардер, но никак не супергерой.

этод метод исполняет фенкцию редюсер на каждом елементе массива, аргументами данной фенкции являются результат прошлого выполнения редьюсера(или дефольное значение если это первое выполнение) аргумент массива на котором мдет текущее выполнения, и сам массив.


	
 	 
			

	 





 















		
 

 

















 
