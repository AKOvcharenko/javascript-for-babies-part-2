https://frontendgods.com/the-double-equals-operator-in-javascript/

1. для добавления джаваскрипта на страницу нужно добавить тег скрипт, причем тег можно добавлять в любое место страницы и сколько угодно раз.

2. допустим ситуация: вы работает в pudelek, и однажды владелец думает, что-то как-то ресурс мало людей посещает, такой икарный контент, а денег не приносит, увольняем половину рабочих поляков и нанимаем на аутсорс индусов - они нам подлючат контекстную рекламу, заработаем миллионы! и однажды вас говорят пофиксить баг, вы открываете код и видитн что-то такое

400 тысяч линий кода просто написаны в html документе.

вы думаете вам плохо? представте другую ситуацию, кто-то пришел на работу, и ему друг говорит там новые фото ратаковски в купальниках на пуделке, а он с детцва увлекаетест купальниками - он вообще модельер, проектирует купальники. 

к сожелению, при добавлении этого тега, браузер перестает рендерить документ и начинает исполнять срипт указаный в этом теге.

3. у вас не хватает времени починить и вы попросили рахманада починить - нужно сделать вынести скрипт в отдельный минимизированый и более проищводительный файл, и подключить его на страницу.

завтра вы приходите на работу и вам начальник говорит, ящек проверь пожалуйста там страница белая на полминуты а потом все загружается но реклама не показывается.
после легкой проверки вы видите что страница висит на пендинг реквеста, сервер не возвращает скрипт. и тут вы замечаете что последний раз логинился на сервера не кшишек, а митхундра, а от кшищека осталост только пожегнальное письмо, которое вам упало в спам и лежащин сервера. 

тогда вы поняли что стоит всетаки лучше починить самому и загружать скрипты без блокировки станицы  

4. и видите вы такое: 

вопервых рахманад разбил логику на два скрипта и вынес их в отдельные файлы - молодец,
но при этом у второго скрипта он указал одновременно и срц и код внутри, а при этом содеожимое тега скрипт будет проигнорировано.


5. с помощью атрибутов асинк и дефер можно перевести документ в асинхронный режим рендеринга - тоесть эти скрипты не будут задерживать рендеринг страницы
как они работают:

асинк: 
- скрипт начинает загружаться - документ рендериться
- второй скрипт начинает загружаться - документ рендериться
- один из скриптов загрузился - рендеринг запаузился на время исолнения скрипта - по окончанию скрипта документ рендерится
- второй скрипт загрузился - рендеринг паузится на время исполнения скрипта - по окончанию документ рендериться 
- исполнение скриптов произойдет в том порядке в котором они загрузились, что не гарантирует нам последовательности указаной в html

defer: 
- скрипты будуь загружаться без блокировки рендеринга страницы, но отработают на ивент который называется DOMContentLoaded.
- в том порядке в котором они написаны в html

тоесть допустим в нашем случае, первый скрипт добавляет на страницу рекламу, а второй скрипт добавляет аналитику сколько раз юзеры взаимодействовали с рекламой.
скрипт два должен использоваться после исполнения скрипта 1. в этом конкретном случае лучше использовать атрибуты дефер для обоих скриптов.

6. отлично мы пофиксили эту проблему, может стоит сделать ревью кода?

смотрю а там написано что-то такое.

 в разных линиях использованы разные ключевые слова для инициализации переменных, вне зависимости от того действительно это переменные или это постоянные.
а ы чем разница между var let const ?



7. var let const разница в hoinsting и block-level доступности этих переменных
что такое hoisting javaScript исполняет скрипты в два захода

- сначала он читает код, поднимая все переменные(которые могут быть подняты), а потом исполняет

поэтому такой код будет интепритирован в такой код;

переменная определенная с помощью зарезервированого слова вар будет поднята, причем будет видна вне зависимости от блока в котором она определена(будет доступна на любом уровне функции/цикла/ифа в котором она определена)

переменная определенная с помощью зарезервированого слова  let, не всплывает - тоесть вы не можете обратиться к ней до момента определения.
в дополнение к тому такая переменная будет блоковая - тоесть доступна только внутри блока в котором она определена + эта переменная может иметь разные значения в разных блоках!
вы не можете определять переменную с таким же именем с помощью слова let в этом случае будет ошибка Identifier 'name' has already been declared 

переменные определенные с помощью cont ведут себя точно так же как и переменные let, но при этом 


15. написания var let const очень важная вещь, потому что если пропустить это слово иногда это может полностью поломать логику скрипта и привести к трудно отлавливаемым багам
например вот тут
 

мы имеем два модуля которые нам склеял вебпак в один скрипт, и в первом модуле нехороший человек упустил var/const. во втором модуле появляется который должен установить имя блажей к сожелению будет имя збигнев.


17 .смотрю я на названия его переменных и начинаю плакать, но слава богу что джаваскрипт имеет хотя бы какието ограничения на названия переменных

и теперь чтобы вы не скучали задача.

spoko идем дальше, и тут совершенно случайно я вижу строку

18. окей приведением типов, в стравнении с приведением типов.  

19. а какие вообще какие базовые типы у джаваскипта. базовых оказывается не много
	1. примитивы - инстансы таких типов имеют одно значение:
		- number - числа в js дробные(все), бесконечность - результат деления 1/0, и NaN - очередная шутка, но чтож
		- string - пустая строка, не пустая строка
		- boolean - очень логтчный оператор, как и положено имеет два значения тру/фолс
		- null - значение неизвестно, или попросту ничего - слово есть а что оно значит нету
		- undefined - значение не определено
	2. Complex - инстансы такого типа могут иметь коллецкию данных - комплексным типом данных являются обект - но обект иммет много подвидов: 
		- обект, массив - если присмотреться в них не такая уж и большая разнитса - обьект - это массив с ключами которые могот быть строкой, а массив это обьект у которого ключи только цыфры
		- функции 

20. есть очень простой способ определения типа инстанса - typeof

и вот что бы он вернул для наших типов
конечно же и тут вы можете увидеть всю прелесть javascripta 
 typeof null это object в typeof функции это function, но javascript это javascript


21. ok мы с вами вспомнили какие базовые типы есть в js, давайте вспомним какие бывают преобразования типов, потому что без этого попросту ние дамы рады

22. приведение типов может быть либо explicit либо implicit. некоторые люди например такие как прошлый я почти всегда использовали implicit, а некоторые люди такие как радек, даже в комментария в пел реквестах пишут используй implicit потому что он работает быстрее. но между работает быстрее и дикий венж очень тонкая грань которую легко перейти
 
23. самыми простыми и очевидными преобразованиями является использования констректоров Number, String, Boolean
так же дополнительно для преобразования в число есть две функции parseInt/parseFloat - которые конвертируют строки похожие на цифры в цифры
дополнительной фенкцией для преобразования в строку является фенкция toString, каджый инстанс который имеет еонструктор класса - имеет этот метод. соответственно null, undefined этого не имееют


24 Но наш новый тиммембер не ищет легких решений, или просто хочет похвастаться своими знаниями поэтому использует неявные преобразования.

самый простое и понятное преобразование - это преобразование к boolean с помощью !! - все комплексные переменные тру - все непустые примитивы тру - пустые примитивы - фолс
при использовании унарного плюса интерпритатор попытается преобразовать значение в число, что можно использовать вместо фенкции parseInt
но уже при использовании бинарного плюса интепритатор(в случае если мы пытаемся сложить строку) будет преобразовывать все слогаемые к строке. что можно использовать вместо фенкции тустринг.
но такая ситуация только с плюсом, при попытке использовать другой бинарный операто напиример - * или / все части будут преобразовываться к числам.

это довольно сложно помнить все эти мелкие детали, вель значительно проще было сделать все явно

хорошо, что же на самом деле написал в том ифе рахманад
2*'$' интерпритатор попробует преобразовать строку  $ в число это ему не удаться - NaN - и помножить на 2. все тот же NaN. а наверное он хотел просто сканкатенировать строки и проверить является сделал ли юзер донейшен на два доллара. только теперь он  сравнивает NaN с помощью двойного равно.



26. а как вообще работает двойное и тройное равно?
тройное равно работает очень просто, сравниваются два операнда, сначала сравниваются их типы, если типы равны потом сравниваются их значения.
все просто и понятно никакого комбинирования. а как рабоает злой младший брат тройного равно двойное равно можно посмотреть здесь

простая схема: 
	- сравниваемые части имеют одинакой тип? - вызываем тройное равно
	- сравниваемые части null и undefined? - возвращаем тру
	- сравниваемы части стринги и числа? - преобразуем стринги в числа и начинаем сравнение 		снова
	- сравниваемыая часть булеан? преобразовываем булеан в число и начинаем снова
	- сравниваемые части обект и стринг/число/символ? продьразовуем обюект в примитив и 			сравниваем снова

отлично мы разобралист как работает двойное и тройное равно а как работает больше меньше?




27. для чисел оно работает логично с точки зрения человека 3<4, 6 > 5. для NaN работает не сильно логично, но хотя бы не вызывает дисонанса NaN нельзя сравнивать ни с чем 

для строк начинается комбинирование первого уровня - строки сравниваются посимвольно причем сравниваются их кодировка Unicode

28. а если мы начинаем сравнивать вещи с разными типами то вообще беда - в этом случае сравниваемые веши преобразуются к числу
 
29 а если начать сравнивать undefined/null с чем-то? - трагедия, 
undefined при приобразовании в число преобразовывается в NaNimmediately invoked function expressions

ладно с этой линейкой кода в ревью разобрались идем дальше осталост всего лишь 666 линий
в этом скрипте реалтзована фенкциональность: в зависимости от того сколько человек нам задонатил он может получить наклейки в бедронке на суперсвежака: 
если задонатил 10 зл то 1 наклейка если 20 зл то 2 наклейки, 30 зл 3 наклейки. максимально можно было получить 5 наклеек.

30 вы оставилт комментарий перепиши на свитч. на следующий день вы приходите на работу и вам щеф говорит что новая фенкциональность наклеек плохо работает, денег не донатят а наклейки уходят. оказалось ночию был ниндзя мерж ваших комментариев и на продакшен пошел вот такой код


31. ладно поправил это, и дальше за ревью, а этот чувак действительно любил писать ифы. осталю ка я каммент чтобы он посмотрел что такое тернарный оператор и использовал его здесь.
ух ты поправил и все должно работать.

32. гaд демет, наверно я зря его  просил почитать о тернарном операторе. нестоит писать тернарный оператор в тернарном операторе а то леонардо вас навестит

33. а что это такое? у нас есть фенкция которая достает какието данные из базы с помощью айдт юзера, потом с помощью этих данных она должна вернуть все донейшены которые сделал юзер, а юзер мог выполнить донейшены в трех разных местах, и поэтому у нас три разных ыункции, чтобы найти донейшены - тяжелая, вешает браузер на 3 секунды, тяжелее, вешает браузер на 5 секунд, и самая тяжелая, вешает комп, нужно перехагружаь. нкжно как-то прорефакторить эту фенкцию. здесь можно применить сразу несколько хаков с помогб. лошическиъ операторов

	1. что бы?ет если база ничего не вернет? тоесть userToken будет undefined кпримеру, можно в этом случае дать userToken значение по умолчанию, если тяжелые фенкции с ним заработают
	2. если не заработают то тогда лучге написать кондишионал выполнение на эти функции
	3. хак называется Short-circuit evaluation 


34. цыклы - Для многократного повторения одного участка кода – есть циклы. в js есть три вида циклов. while, do-while, for;

цикл while проверяет условие указаное в блоке while, и если условие правдивое, то он выполняет тело цикла, после чего делает проверку еще раз
цикл do while работает практически так же только сначала выполняет условие а потом делает проверку. 
цикл for тспользуется более часто, да и к томе же с помошью него можно воспроизвести цикл while, а вот так можно сделать бесконечный цикл аналог while(true)

35 выйти из цикла можно не только в момент когда проверка возвращает фолс но и принудительно. для этого есть директива break - которая просто прекращает выполнения цикла
36 break имеет младшую сестру, которая прерывает исполнение цикла но только для текущей операции
и перескакивает в следующую
ксожелению break/continue нельзя использовать в тернанрном операторе. потому что тернарный оператор должен что-то вернуть, а эти директивы ничего не возвразают.

а что будет если у меня цикл в цикле?

и я хоче прервать выполнение какого-то из внешних цыклов из внутреннего? нет ничего проще, для этого нужно всего лиш поставать метку на цакле который мы хотим прервать, и использовать break имя метки - вот так.
зорошо что метки нельзя использовать как аналог go to в других языках, потому что в джаваскрипте и так не все хорошо без этого



40 function - очень часто нам нужно повторять одно и тоже действие много раз. можно копировать и вставлять, но это это будет просто нереально тяжело поддерживать - внося изменения в миллионе мест одновременно. 
фенкция - это кирпичик из которого должен строиться наш скрипт. 

функция может быть создана сногими способоми давайте посотрим какими начнем с этих трех

1. function declaration
2. function expression
3. named function expression

работают они одинаково - 
	- фкнкции имеют переменныекоторые они могут использовать 
		- эти переменные могу быть обьявлены внутри функции - такие переменные называются локальные переменные. локальные переменные доступны только внутри фенкции и не доступны снарежи.
		- так же фенкция может обратиться к внешней переменной - такие переменные называются глобальными
	- функции тмеют аргументы которые они могут принимать, они доступны через псевдо массив arguments
	- функции могут возвращать результат своего выполнения или возврашать undefined		

разница в 
	- хоистинге
	- function declaration обявленное в блоке иф, видно только в этом блоке 
	- имя named function expression доступно только внутри самой функции

41 еще можно инициалтзоровать функции такими способами

	- arrow function
	- new Function()
	- 

тут несколько больше отличий
	- arrow function не имеет своего this
	- слгдовательно она не может быть и конструктором	
	- имеет своего массива arguments - чтобы его использовать нужно делать спред агрументов

	- я видел использование new Function только пару раз - это просто дикие хаки, когда ты создаешь функцию из стрингов. например этот стринг зависит от того что тебе пришло в ответе с сервера, и ты 			не можешь создать функцию нормальным способом 

immediately invoked function expressions - это просто сказка, самое лучшее что есть в джаваскипте. поскольку позволяют держать в себе локальные переменные которые будуи доступны только внутрию самый просто способо написание модулей в js
	












		
 

 

















 
